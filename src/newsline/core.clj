(ns newsline.core
  (:gen-class)
  (:use [clj-wordnet.core]
  					[opennlp.nlp]
  					[opennlp.tools.filters]
  					[opennlp.treebank])
  (:require [clojure.math.numeric-tower :as math]))

(require '(stemmers core soundex porter))

(def get-sentences (make-sentence-detector "models/en-sent.bin"))
(def tokenize (make-tokenizer "models/en-token.bin"))
(def pos-tag (make-pos-tagger "models/en-pos-maxent.bin"))
(def name-find (make-name-finder "models/en-ner-person.bin"))
(def chunker (make-treebank-chunker "models/en-chunker.bin"))

(def wordnet (make-dictionary "models/dict/"))
(def wordBasket (list))
(def value "value")


(defn lemma
	[word]
	(:lemma word))

(defn word-net
	"Returns a word in the IWord format of JWI. Providing the pos tag is optional"
	[word]
	(wordnet word))

(defn relatedSynsets
	"Returns the related synsets of the given word"
	[word]
	(if (not (empty? word)) (flatten(vals(related-synsets word :hypernym)))))

(defn postagger
	"Returns whether the word is a noun or a verb"
	[tag]
	(if (or (= (.toString tag) "NN") (= (.toString tag) "NNS") (= (.toString tag) "NNP") (= (.toString tag) "NNPS"))
					"noun" "verb"))

(defn checkWord
  "Checks if a word already exists in the Basket"
  [wordID]
  (def id wordID)
  (def Basketcount (count wordBasket))
  (def basket wordBasket)
  (def flag true)
  (if (= Basketcount 0) (def flag false))
  (loop[i 0]
    (when (< i Basketcount)
      (def wordid ((first basket) :id))
      (if (not (= wordid id)) (def flag false))
      (recur (inc i))))
  flag)

(defn addWord
  "Adds a Word to the basket. Adds only first sense of the word."
  [word & prevWord]
  (def w word)
  (def wordnetWordID (.getSynsetID (:id w)))
  (if (not (= nil prevWord)) (println ((first prevWord) :value)))
  (if (not (= nil prevWord)) (def prevWordID (.getSynsetID (:id (first prevWord)))))
  (if (not (checkWord wordnetWordID)) 
    (do
      (if (empty? prevWord) (def weight 1) 
        (def weight (math/abs (* (/ 1000.0 (- (.getOffset wordnetWordID) (.getOffset prevWordID))) 1))))
      (def wordHash (hash-map :word (:lemma w) :id wordnetWordID :value weight))
      (def wordBasket (cons wordHash wordBasket))
    ))
  )

(defn addSynsets
  "Add the synsets generated by the synsets function."
  [synsetList prevword]
  (def cnt (count synsetList))
  (def synset synsetList)
  (loop[i 0]
    (when(< i cnt)
      (def word (first synset))      
      (addWord word prevword)
      (def synset (rest synset))
      (recur (inc i))
      )))

(defn synsets
  "A synset function to get synsets of all possible meanings of the word."
  [word]
  (def newsynsets (relatedSynsets word))
  (addSynsets newsynsets word)
  ; (def cnts (count word))
  ; (println cnts)
  ; (def synsetword word)
  ; (loop [j 0]
  ;   (when (< j cnts)
  ;     (def newsynsets (relatedSynsets (first synsetword)))
  ;     (addSynsets newsynsets (first synsetword))
  ;     (def synsetword (rest synsetword))
  ;     (recur (inc j))
  ;     ))
)

(defn filterWords
  "Remove the words below a given threshold"
  [thres]
  (def basketCopy wordBasket)
  (def newBasket (list))
  (def basketCount (count basket))
  (loop [i 0]
    (when (< i basketCount)
      (if (> ((first basketCopy) :value) thres) (def newBasket (cons (first basketCopy) newBasket)))
      (def basketCopy (rest basketCopy))
      (recur (inc i))
      ))
  (def wordBasket newBasket)
)

(defn printBasketvalue
  "Print the value of the basket of words"
  [basket]
  (def basketCopy basket)
  (def basketCount (count basket))
  (loop [i 0]
    (when (< i basketCount)
      (print ((first basketCopy) :id))
      (print "--" ((first basketCopy) :word))
      (println ((first basketCopy) :value))
      (def basketCopy (rest basketCopy))
      (recur (inc i))
      )))

(defn printBasketID
  "Print the SynsetID of the basket of words"
  [basket]
  (def a basket)
  (def basketCount (count basket))
  (loop [i 0]
    (when (< i basketCount)
      (print ((first a) :word)"-")
      (println (.getOffset ((first a) :id)))
      (def a (rest a))
      (recur (inc i))
      )))

(defn -main
	"Main driver function."
  [& args]
  (def s (slurp (apply str (first args))))
  (def sentences (get-sentences s))
	(def tokens (nouns-and-verbs (pos-tag (tokenize s))))
		(def counts (count tokens))
	(loop [i 0]
		(when (< i counts)
			(def word (stemmers.core/stems ((first tokens) 0)))
			(def postag (postagger ((first tokens) 1)))
			(println (first tokens))
      ;(println (first word))
			(println postag)
			(def wordnetWord (word-net (first word)))
      (def senseNumbers (count wordnetWord))
      (loop  [j 0]
        (when (< j senseNumbers)
          (if (not (empty? wordnetWord)) 
            (do
              (addWord (first wordnetWord)) 
              (println (:lemma (first wordnetWord)))
          ;(if (not (= wordnetWord nil)) (println (:lemma wordnetWord)))
              (synsets (first wordnetWord))
              (def wordnetWord (rest wordnetWord)))
            )
          (recur (inc j))  
          ))
			;(if (not (= synsetWords nil)) (println (map :lemma synsetWords)))
      (println counts)
      (println "<------------------------------------------------>")
			(def tokens (rest tokens))
			(recur (inc i))))
  (filterWords 0.3)

  (printBasketvalue wordBasket)
  (println (count wordBasket))
)

